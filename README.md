# Stupifier
#### Video Demo:  [Youtube] (https://youtu.be/LAYp67Ayl_8)
#### Description:
The Stupifier is a browser-based guessing game that "stupifies" web searches!
The challenge is to guess what word produced the weird search results retrived by the Stupifier. For simplicity’s sake, I will refer to that word as ‘search’ and to the users guess as ‘guess’.
The game has 2 modes: 1 Player (the machine chooses a search for you) and Multiplayer (a friend can choose a search for you to guess).
My aplication.py and helpers.py files contain all the logic of the game: The apps routes (login, register, etc) and the functions that make the game work. In helpers.py, I have the login_required() function and also a custom dictionary() function that uploads a list of words from a file into a numbered dictionary, chooses a random number (within the dictionary's range) and then returns the word corresponding to that number. In application.py, I created a separate route (/dic) to be able to return the JSON object that I needed to send to my Javascript to produce the results —which the user uses to make a guess — because all my other routes needed to return templates or redirect to other pages and it’s impossible to return two things at the same time. Same thing for /ret. Then, I get search and guess each into a variable and then compare them. If the two strings match, the user wins a point (if not, the score doesn’t change). This is how 1 Player Mode works.
For Multiplayer Mode, I use request.form.get to get the input form player 1 (the one choosing the search) and the input from player 2 (guess) and compare the two. I created two different routes and two html pages for the multiplayer version (/multi1 and /multi2) to manage requests and avoid Null values (when both input forms were on the same page, it made the request for input1 two times, which produced a 'None' value, creating problems in comparison and scoring).
To make it more user-friendly, I use the .lower() and .rstrip() methods, to compare the search and the guess case-insensitively and ignore trailing spaces, in case someone accidentally types a space after the guess (which some phones automatically do).
I didn’t program the application to keep asking for user input if there wasn’t any because I thought it might create bugs in my code and also because the user can understand from the lack of points gained that they should input something. Relating to password hashing, I used a salting method of ‘plain’ only because this is a academic project and there is no critical information being stored like emails or financial information and it’s easier for me as the programmer to see the information and catch potencial bugs. Otherwise, I would have used other methods.
The users.db database is where the scoring is stored. I have a table for the users and a separate one for their scores. The scores are updated through SQL queries in application.py.
The templates folder contains all my html pages: index (the homepage), layout (the general layout for all my pages), login, register, multi1 and multi2 (the pages for player 1 and player 2 in Multiplayer Mode, respectively), player (1 Player Mode) and results (the answer and score). I used Givewater (the actual search engine) because it allowed me to manipulate the url, showed only the images without their titles (from which the used could infer the search) and also showed the weirdest results.
In player.html and multi2.html there is the Javascript code that makes the Stupifier a different search engine: I used Jquery and Ajax calls to manipulate the url that produces the results by including 'weirdest' before the search, so the request I'm actually making is 'serp?qc=images&q=weirdest + {search}'.
The results.html page simply presents information to the user: if their guess was correct, what was the right answer, what was their answer, and what their current score is. I also included buttons throughout as additional features for a better user experience (Instructions, Switch Game Mode, Logout, Try again) which appear in all pages (except for the Switch button that is hidden in the results page).
Finally, the static folder has my css file and some gifs I use in the homepage. The all.css file controls the visual aspect of all pages in the application and takes care of responsiveness, making the game desktop and mobile-friendly. The dictionaries folder has the list I upload into my program and a few more.
When it comes to the UI design, the mobile and desktop version are similar. The gif(s) in the homepage provide context and interest with the motion aspect. The mobile version has bigger letters, its layout is more centered and takes more advantage of vertical space, for which the submit buttons are under the input field instead of next to it. Also, the top buttons beside the score are included in a div that is activated by the hamburger menu button. I chose to locate that div at the top, as a second navigation bar.
In terms of improvements, I think the Try again button should redirect the user to the game Mode they came from. I would also like the multiplayer version to be able to played in separate devices, as in Player 1 chooses the search and submits, sends the results url to Player 2 and they take a guess. But overall, I really like how this project turned out and the whole course in general.